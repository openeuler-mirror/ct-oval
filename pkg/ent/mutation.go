// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"ct_oval_tool/pkg/ent/cveref"
	"ct_oval_tool/pkg/ent/object"
	"ct_oval_tool/pkg/ent/oval"
	"ct_oval_tool/pkg/ent/predicate"
	"ct_oval_tool/pkg/ent/state"
	"ct_oval_tool/pkg/ent/test"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCveref = "Cveref"
	TypeObject = "Object"
	TypeOval   = "Oval"
	TypeState  = "State"
	TypeTest   = "Test"
)

// CverefMutation represents an operation that mutates the Cveref nodes in the graph.
type CverefMutation struct {
	config
	op            Op
	typ           string
	id            *int
	ref_id        *string
	ref_url       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Cveref, error)
	predicates    []predicate.Cveref
}

var _ ent.Mutation = (*CverefMutation)(nil)

// cverefOption allows management of the mutation configuration using functional options.
type cverefOption func(*CverefMutation)

// newCverefMutation creates new mutation for the Cveref entity.
func newCverefMutation(c config, op Op, opts ...cverefOption) *CverefMutation {
	m := &CverefMutation{
		config:        c,
		op:            op,
		typ:           TypeCveref,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCverefID sets the ID field of the mutation.
func withCverefID(id int) cverefOption {
	return func(m *CverefMutation) {
		var (
			err   error
			once  sync.Once
			value *Cveref
		)
		m.oldValue = func(ctx context.Context) (*Cveref, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cveref.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCveref sets the old Cveref of the mutation.
func withCveref(node *Cveref) cverefOption {
	return func(m *CverefMutation) {
		m.oldValue = func(context.Context) (*Cveref, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CverefMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CverefMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CverefMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CverefMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cveref.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRefID sets the "ref_id" field.
func (m *CverefMutation) SetRefID(s string) {
	m.ref_id = &s
}

// RefID returns the value of the "ref_id" field in the mutation.
func (m *CverefMutation) RefID() (r string, exists bool) {
	v := m.ref_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRefID returns the old "ref_id" field's value of the Cveref entity.
// If the Cveref object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CverefMutation) OldRefID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefID: %w", err)
	}
	return oldValue.RefID, nil
}

// ResetRefID resets all changes to the "ref_id" field.
func (m *CverefMutation) ResetRefID() {
	m.ref_id = nil
}

// SetRefURL sets the "ref_url" field.
func (m *CverefMutation) SetRefURL(s string) {
	m.ref_url = &s
}

// RefURL returns the value of the "ref_url" field in the mutation.
func (m *CverefMutation) RefURL() (r string, exists bool) {
	v := m.ref_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRefURL returns the old "ref_url" field's value of the Cveref entity.
// If the Cveref object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CverefMutation) OldRefURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefURL: %w", err)
	}
	return oldValue.RefURL, nil
}

// ResetRefURL resets all changes to the "ref_url" field.
func (m *CverefMutation) ResetRefURL() {
	m.ref_url = nil
}

// Where appends a list predicates to the CverefMutation builder.
func (m *CverefMutation) Where(ps ...predicate.Cveref) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CverefMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CverefMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Cveref, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CverefMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CverefMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Cveref).
func (m *CverefMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CverefMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.ref_id != nil {
		fields = append(fields, cveref.FieldRefID)
	}
	if m.ref_url != nil {
		fields = append(fields, cveref.FieldRefURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CverefMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cveref.FieldRefID:
		return m.RefID()
	case cveref.FieldRefURL:
		return m.RefURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CverefMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cveref.FieldRefID:
		return m.OldRefID(ctx)
	case cveref.FieldRefURL:
		return m.OldRefURL(ctx)
	}
	return nil, fmt.Errorf("unknown Cveref field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CverefMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cveref.FieldRefID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefID(v)
		return nil
	case cveref.FieldRefURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefURL(v)
		return nil
	}
	return fmt.Errorf("unknown Cveref field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CverefMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CverefMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CverefMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Cveref numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CverefMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CverefMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CverefMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Cveref nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CverefMutation) ResetField(name string) error {
	switch name {
	case cveref.FieldRefID:
		m.ResetRefID()
		return nil
	case cveref.FieldRefURL:
		m.ResetRefURL()
		return nil
	}
	return fmt.Errorf("unknown Cveref field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CverefMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CverefMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CverefMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CverefMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CverefMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CverefMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CverefMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Cveref unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CverefMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Cveref edge %s", name)
}

// ObjectMutation represents an operation that mutates the Object nodes in the graph.
type ObjectMutation struct {
	config
	op            Op
	typ           string
	id            *int
	object_id     *string
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Object, error)
	predicates    []predicate.Object
}

var _ ent.Mutation = (*ObjectMutation)(nil)

// objectOption allows management of the mutation configuration using functional options.
type objectOption func(*ObjectMutation)

// newObjectMutation creates new mutation for the Object entity.
func newObjectMutation(c config, op Op, opts ...objectOption) *ObjectMutation {
	m := &ObjectMutation{
		config:        c,
		op:            op,
		typ:           TypeObject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withObjectID sets the ID field of the mutation.
func withObjectID(id int) objectOption {
	return func(m *ObjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Object
		)
		m.oldValue = func(ctx context.Context) (*Object, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Object.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withObject sets the old Object of the mutation.
func withObject(node *Object) objectOption {
	return func(m *ObjectMutation) {
		m.oldValue = func(context.Context) (*Object, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ObjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ObjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ObjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ObjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Object.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetObjectID sets the "object_id" field.
func (m *ObjectMutation) SetObjectID(s string) {
	m.object_id = &s
}

// ObjectID returns the value of the "object_id" field in the mutation.
func (m *ObjectMutation) ObjectID() (r string, exists bool) {
	v := m.object_id
	if v == nil {
		return
	}
	return *v, true
}

// OldObjectID returns the old "object_id" field's value of the Object entity.
// If the Object object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectMutation) OldObjectID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjectID: %w", err)
	}
	return oldValue.ObjectID, nil
}

// ResetObjectID resets all changes to the "object_id" field.
func (m *ObjectMutation) ResetObjectID() {
	m.object_id = nil
}

// SetName sets the "name" field.
func (m *ObjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ObjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Object entity.
// If the Object object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ObjectMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the ObjectMutation builder.
func (m *ObjectMutation) Where(ps ...predicate.Object) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ObjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ObjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Object, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ObjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ObjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Object).
func (m *ObjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ObjectMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.object_id != nil {
		fields = append(fields, object.FieldObjectID)
	}
	if m.name != nil {
		fields = append(fields, object.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ObjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case object.FieldObjectID:
		return m.ObjectID()
	case object.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ObjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case object.FieldObjectID:
		return m.OldObjectID(ctx)
	case object.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Object field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ObjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case object.FieldObjectID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjectID(v)
		return nil
	case object.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Object field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ObjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ObjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ObjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Object numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ObjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ObjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ObjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Object nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ObjectMutation) ResetField(name string) error {
	switch name {
	case object.FieldObjectID:
		m.ResetObjectID()
		return nil
	case object.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Object field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ObjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ObjectMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ObjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ObjectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ObjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ObjectMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ObjectMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Object unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ObjectMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Object edge %s", name)
}

// OvalMutation represents an operation that mutates the Oval nodes in the graph.
type OvalMutation struct {
	config
	op             Op
	typ            string
	id             *string
	productname    *string
	productversion *string
	schemaversion  *string
	ovalversion    *string
	class          *string
	family         *string
	copyright      *string
	timestamp      *string
	title          *string
	description    *string
	severity       *string
	issuedate      *string
	platform       *string
	arch_list      *string
	cve_list       *string
	test_list      *string
	object_list    *string
	state_list     *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Oval, error)
	predicates     []predicate.Oval
}

var _ ent.Mutation = (*OvalMutation)(nil)

// ovalOption allows management of the mutation configuration using functional options.
type ovalOption func(*OvalMutation)

// newOvalMutation creates new mutation for the Oval entity.
func newOvalMutation(c config, op Op, opts ...ovalOption) *OvalMutation {
	m := &OvalMutation{
		config:        c,
		op:            op,
		typ:           TypeOval,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOvalID sets the ID field of the mutation.
func withOvalID(id string) ovalOption {
	return func(m *OvalMutation) {
		var (
			err   error
			once  sync.Once
			value *Oval
		)
		m.oldValue = func(ctx context.Context) (*Oval, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Oval.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOval sets the old Oval of the mutation.
func withOval(node *Oval) ovalOption {
	return func(m *OvalMutation) {
		m.oldValue = func(context.Context) (*Oval, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OvalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OvalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Oval entities.
func (m *OvalMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OvalMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OvalMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Oval.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProductname sets the "productname" field.
func (m *OvalMutation) SetProductname(s string) {
	m.productname = &s
}

// Productname returns the value of the "productname" field in the mutation.
func (m *OvalMutation) Productname() (r string, exists bool) {
	v := m.productname
	if v == nil {
		return
	}
	return *v, true
}

// OldProductname returns the old "productname" field's value of the Oval entity.
// If the Oval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OvalMutation) OldProductname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductname: %w", err)
	}
	return oldValue.Productname, nil
}

// ResetProductname resets all changes to the "productname" field.
func (m *OvalMutation) ResetProductname() {
	m.productname = nil
}

// SetProductversion sets the "productversion" field.
func (m *OvalMutation) SetProductversion(s string) {
	m.productversion = &s
}

// Productversion returns the value of the "productversion" field in the mutation.
func (m *OvalMutation) Productversion() (r string, exists bool) {
	v := m.productversion
	if v == nil {
		return
	}
	return *v, true
}

// OldProductversion returns the old "productversion" field's value of the Oval entity.
// If the Oval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OvalMutation) OldProductversion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductversion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductversion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductversion: %w", err)
	}
	return oldValue.Productversion, nil
}

// ResetProductversion resets all changes to the "productversion" field.
func (m *OvalMutation) ResetProductversion() {
	m.productversion = nil
}

// SetSchemaversion sets the "schemaversion" field.
func (m *OvalMutation) SetSchemaversion(s string) {
	m.schemaversion = &s
}

// Schemaversion returns the value of the "schemaversion" field in the mutation.
func (m *OvalMutation) Schemaversion() (r string, exists bool) {
	v := m.schemaversion
	if v == nil {
		return
	}
	return *v, true
}

// OldSchemaversion returns the old "schemaversion" field's value of the Oval entity.
// If the Oval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OvalMutation) OldSchemaversion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchemaversion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchemaversion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchemaversion: %w", err)
	}
	return oldValue.Schemaversion, nil
}

// ResetSchemaversion resets all changes to the "schemaversion" field.
func (m *OvalMutation) ResetSchemaversion() {
	m.schemaversion = nil
}

// SetOvalversion sets the "ovalversion" field.
func (m *OvalMutation) SetOvalversion(s string) {
	m.ovalversion = &s
}

// Ovalversion returns the value of the "ovalversion" field in the mutation.
func (m *OvalMutation) Ovalversion() (r string, exists bool) {
	v := m.ovalversion
	if v == nil {
		return
	}
	return *v, true
}

// OldOvalversion returns the old "ovalversion" field's value of the Oval entity.
// If the Oval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OvalMutation) OldOvalversion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOvalversion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOvalversion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOvalversion: %w", err)
	}
	return oldValue.Ovalversion, nil
}

// ResetOvalversion resets all changes to the "ovalversion" field.
func (m *OvalMutation) ResetOvalversion() {
	m.ovalversion = nil
}

// SetClass sets the "class" field.
func (m *OvalMutation) SetClass(s string) {
	m.class = &s
}

// Class returns the value of the "class" field in the mutation.
func (m *OvalMutation) Class() (r string, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldClass returns the old "class" field's value of the Oval entity.
// If the Oval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OvalMutation) OldClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClass: %w", err)
	}
	return oldValue.Class, nil
}

// ResetClass resets all changes to the "class" field.
func (m *OvalMutation) ResetClass() {
	m.class = nil
}

// SetFamily sets the "family" field.
func (m *OvalMutation) SetFamily(s string) {
	m.family = &s
}

// Family returns the value of the "family" field in the mutation.
func (m *OvalMutation) Family() (r string, exists bool) {
	v := m.family
	if v == nil {
		return
	}
	return *v, true
}

// OldFamily returns the old "family" field's value of the Oval entity.
// If the Oval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OvalMutation) OldFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamily: %w", err)
	}
	return oldValue.Family, nil
}

// ResetFamily resets all changes to the "family" field.
func (m *OvalMutation) ResetFamily() {
	m.family = nil
}

// SetCopyright sets the "copyright" field.
func (m *OvalMutation) SetCopyright(s string) {
	m.copyright = &s
}

// Copyright returns the value of the "copyright" field in the mutation.
func (m *OvalMutation) Copyright() (r string, exists bool) {
	v := m.copyright
	if v == nil {
		return
	}
	return *v, true
}

// OldCopyright returns the old "copyright" field's value of the Oval entity.
// If the Oval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OvalMutation) OldCopyright(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCopyright is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCopyright requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopyright: %w", err)
	}
	return oldValue.Copyright, nil
}

// ResetCopyright resets all changes to the "copyright" field.
func (m *OvalMutation) ResetCopyright() {
	m.copyright = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *OvalMutation) SetTimestamp(s string) {
	m.timestamp = &s
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *OvalMutation) Timestamp() (r string, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Oval entity.
// If the Oval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OvalMutation) OldTimestamp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *OvalMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetTitle sets the "title" field.
func (m *OvalMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *OvalMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Oval entity.
// If the Oval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OvalMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *OvalMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *OvalMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OvalMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Oval entity.
// If the Oval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OvalMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *OvalMutation) ResetDescription() {
	m.description = nil
}

// SetSeverity sets the "severity" field.
func (m *OvalMutation) SetSeverity(s string) {
	m.severity = &s
}

// Severity returns the value of the "severity" field in the mutation.
func (m *OvalMutation) Severity() (r string, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the Oval entity.
// If the Oval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OvalMutation) OldSeverity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *OvalMutation) ResetSeverity() {
	m.severity = nil
}

// SetIssuedate sets the "issuedate" field.
func (m *OvalMutation) SetIssuedate(s string) {
	m.issuedate = &s
}

// Issuedate returns the value of the "issuedate" field in the mutation.
func (m *OvalMutation) Issuedate() (r string, exists bool) {
	v := m.issuedate
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuedate returns the old "issuedate" field's value of the Oval entity.
// If the Oval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OvalMutation) OldIssuedate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuedate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuedate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuedate: %w", err)
	}
	return oldValue.Issuedate, nil
}

// ResetIssuedate resets all changes to the "issuedate" field.
func (m *OvalMutation) ResetIssuedate() {
	m.issuedate = nil
}

// SetPlatform sets the "platform" field.
func (m *OvalMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *OvalMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Oval entity.
// If the Oval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OvalMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *OvalMutation) ResetPlatform() {
	m.platform = nil
}

// SetArchList sets the "arch_list" field.
func (m *OvalMutation) SetArchList(s string) {
	m.arch_list = &s
}

// ArchList returns the value of the "arch_list" field in the mutation.
func (m *OvalMutation) ArchList() (r string, exists bool) {
	v := m.arch_list
	if v == nil {
		return
	}
	return *v, true
}

// OldArchList returns the old "arch_list" field's value of the Oval entity.
// If the Oval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OvalMutation) OldArchList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchList: %w", err)
	}
	return oldValue.ArchList, nil
}

// ResetArchList resets all changes to the "arch_list" field.
func (m *OvalMutation) ResetArchList() {
	m.arch_list = nil
}

// SetCveList sets the "cve_list" field.
func (m *OvalMutation) SetCveList(s string) {
	m.cve_list = &s
}

// CveList returns the value of the "cve_list" field in the mutation.
func (m *OvalMutation) CveList() (r string, exists bool) {
	v := m.cve_list
	if v == nil {
		return
	}
	return *v, true
}

// OldCveList returns the old "cve_list" field's value of the Oval entity.
// If the Oval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OvalMutation) OldCveList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCveList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCveList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCveList: %w", err)
	}
	return oldValue.CveList, nil
}

// ResetCveList resets all changes to the "cve_list" field.
func (m *OvalMutation) ResetCveList() {
	m.cve_list = nil
}

// SetTestList sets the "test_list" field.
func (m *OvalMutation) SetTestList(s string) {
	m.test_list = &s
}

// TestList returns the value of the "test_list" field in the mutation.
func (m *OvalMutation) TestList() (r string, exists bool) {
	v := m.test_list
	if v == nil {
		return
	}
	return *v, true
}

// OldTestList returns the old "test_list" field's value of the Oval entity.
// If the Oval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OvalMutation) OldTestList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestList: %w", err)
	}
	return oldValue.TestList, nil
}

// ResetTestList resets all changes to the "test_list" field.
func (m *OvalMutation) ResetTestList() {
	m.test_list = nil
}

// SetObjectList sets the "object_list" field.
func (m *OvalMutation) SetObjectList(s string) {
	m.object_list = &s
}

// ObjectList returns the value of the "object_list" field in the mutation.
func (m *OvalMutation) ObjectList() (r string, exists bool) {
	v := m.object_list
	if v == nil {
		return
	}
	return *v, true
}

// OldObjectList returns the old "object_list" field's value of the Oval entity.
// If the Oval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OvalMutation) OldObjectList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObjectList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObjectList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjectList: %w", err)
	}
	return oldValue.ObjectList, nil
}

// ResetObjectList resets all changes to the "object_list" field.
func (m *OvalMutation) ResetObjectList() {
	m.object_list = nil
}

// SetStateList sets the "state_list" field.
func (m *OvalMutation) SetStateList(s string) {
	m.state_list = &s
}

// StateList returns the value of the "state_list" field in the mutation.
func (m *OvalMutation) StateList() (r string, exists bool) {
	v := m.state_list
	if v == nil {
		return
	}
	return *v, true
}

// OldStateList returns the old "state_list" field's value of the Oval entity.
// If the Oval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OvalMutation) OldStateList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateList: %w", err)
	}
	return oldValue.StateList, nil
}

// ResetStateList resets all changes to the "state_list" field.
func (m *OvalMutation) ResetStateList() {
	m.state_list = nil
}

// Where appends a list predicates to the OvalMutation builder.
func (m *OvalMutation) Where(ps ...predicate.Oval) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OvalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OvalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Oval, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OvalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OvalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Oval).
func (m *OvalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OvalMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.productname != nil {
		fields = append(fields, oval.FieldProductname)
	}
	if m.productversion != nil {
		fields = append(fields, oval.FieldProductversion)
	}
	if m.schemaversion != nil {
		fields = append(fields, oval.FieldSchemaversion)
	}
	if m.ovalversion != nil {
		fields = append(fields, oval.FieldOvalversion)
	}
	if m.class != nil {
		fields = append(fields, oval.FieldClass)
	}
	if m.family != nil {
		fields = append(fields, oval.FieldFamily)
	}
	if m.copyright != nil {
		fields = append(fields, oval.FieldCopyright)
	}
	if m.timestamp != nil {
		fields = append(fields, oval.FieldTimestamp)
	}
	if m.title != nil {
		fields = append(fields, oval.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, oval.FieldDescription)
	}
	if m.severity != nil {
		fields = append(fields, oval.FieldSeverity)
	}
	if m.issuedate != nil {
		fields = append(fields, oval.FieldIssuedate)
	}
	if m.platform != nil {
		fields = append(fields, oval.FieldPlatform)
	}
	if m.arch_list != nil {
		fields = append(fields, oval.FieldArchList)
	}
	if m.cve_list != nil {
		fields = append(fields, oval.FieldCveList)
	}
	if m.test_list != nil {
		fields = append(fields, oval.FieldTestList)
	}
	if m.object_list != nil {
		fields = append(fields, oval.FieldObjectList)
	}
	if m.state_list != nil {
		fields = append(fields, oval.FieldStateList)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OvalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oval.FieldProductname:
		return m.Productname()
	case oval.FieldProductversion:
		return m.Productversion()
	case oval.FieldSchemaversion:
		return m.Schemaversion()
	case oval.FieldOvalversion:
		return m.Ovalversion()
	case oval.FieldClass:
		return m.Class()
	case oval.FieldFamily:
		return m.Family()
	case oval.FieldCopyright:
		return m.Copyright()
	case oval.FieldTimestamp:
		return m.Timestamp()
	case oval.FieldTitle:
		return m.Title()
	case oval.FieldDescription:
		return m.Description()
	case oval.FieldSeverity:
		return m.Severity()
	case oval.FieldIssuedate:
		return m.Issuedate()
	case oval.FieldPlatform:
		return m.Platform()
	case oval.FieldArchList:
		return m.ArchList()
	case oval.FieldCveList:
		return m.CveList()
	case oval.FieldTestList:
		return m.TestList()
	case oval.FieldObjectList:
		return m.ObjectList()
	case oval.FieldStateList:
		return m.StateList()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OvalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oval.FieldProductname:
		return m.OldProductname(ctx)
	case oval.FieldProductversion:
		return m.OldProductversion(ctx)
	case oval.FieldSchemaversion:
		return m.OldSchemaversion(ctx)
	case oval.FieldOvalversion:
		return m.OldOvalversion(ctx)
	case oval.FieldClass:
		return m.OldClass(ctx)
	case oval.FieldFamily:
		return m.OldFamily(ctx)
	case oval.FieldCopyright:
		return m.OldCopyright(ctx)
	case oval.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case oval.FieldTitle:
		return m.OldTitle(ctx)
	case oval.FieldDescription:
		return m.OldDescription(ctx)
	case oval.FieldSeverity:
		return m.OldSeverity(ctx)
	case oval.FieldIssuedate:
		return m.OldIssuedate(ctx)
	case oval.FieldPlatform:
		return m.OldPlatform(ctx)
	case oval.FieldArchList:
		return m.OldArchList(ctx)
	case oval.FieldCveList:
		return m.OldCveList(ctx)
	case oval.FieldTestList:
		return m.OldTestList(ctx)
	case oval.FieldObjectList:
		return m.OldObjectList(ctx)
	case oval.FieldStateList:
		return m.OldStateList(ctx)
	}
	return nil, fmt.Errorf("unknown Oval field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OvalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oval.FieldProductname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductname(v)
		return nil
	case oval.FieldProductversion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductversion(v)
		return nil
	case oval.FieldSchemaversion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchemaversion(v)
		return nil
	case oval.FieldOvalversion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOvalversion(v)
		return nil
	case oval.FieldClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClass(v)
		return nil
	case oval.FieldFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamily(v)
		return nil
	case oval.FieldCopyright:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopyright(v)
		return nil
	case oval.FieldTimestamp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case oval.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case oval.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case oval.FieldSeverity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case oval.FieldIssuedate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuedate(v)
		return nil
	case oval.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case oval.FieldArchList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchList(v)
		return nil
	case oval.FieldCveList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCveList(v)
		return nil
	case oval.FieldTestList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestList(v)
		return nil
	case oval.FieldObjectList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjectList(v)
		return nil
	case oval.FieldStateList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateList(v)
		return nil
	}
	return fmt.Errorf("unknown Oval field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OvalMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OvalMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OvalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Oval numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OvalMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OvalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OvalMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Oval nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OvalMutation) ResetField(name string) error {
	switch name {
	case oval.FieldProductname:
		m.ResetProductname()
		return nil
	case oval.FieldProductversion:
		m.ResetProductversion()
		return nil
	case oval.FieldSchemaversion:
		m.ResetSchemaversion()
		return nil
	case oval.FieldOvalversion:
		m.ResetOvalversion()
		return nil
	case oval.FieldClass:
		m.ResetClass()
		return nil
	case oval.FieldFamily:
		m.ResetFamily()
		return nil
	case oval.FieldCopyright:
		m.ResetCopyright()
		return nil
	case oval.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case oval.FieldTitle:
		m.ResetTitle()
		return nil
	case oval.FieldDescription:
		m.ResetDescription()
		return nil
	case oval.FieldSeverity:
		m.ResetSeverity()
		return nil
	case oval.FieldIssuedate:
		m.ResetIssuedate()
		return nil
	case oval.FieldPlatform:
		m.ResetPlatform()
		return nil
	case oval.FieldArchList:
		m.ResetArchList()
		return nil
	case oval.FieldCveList:
		m.ResetCveList()
		return nil
	case oval.FieldTestList:
		m.ResetTestList()
		return nil
	case oval.FieldObjectList:
		m.ResetObjectList()
		return nil
	case oval.FieldStateList:
		m.ResetStateList()
		return nil
	}
	return fmt.Errorf("unknown Oval field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OvalMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OvalMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OvalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OvalMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OvalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OvalMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OvalMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Oval unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OvalMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Oval edge %s", name)
}

// StateMutation represents an operation that mutates the State nodes in the graph.
type StateMutation struct {
	config
	op            Op
	typ           string
	id            *int
	state_id      *string
	value         *string
	tag           *string
	datatype      *string
	operation     *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*State, error)
	predicates    []predicate.State
}

var _ ent.Mutation = (*StateMutation)(nil)

// stateOption allows management of the mutation configuration using functional options.
type stateOption func(*StateMutation)

// newStateMutation creates new mutation for the State entity.
func newStateMutation(c config, op Op, opts ...stateOption) *StateMutation {
	m := &StateMutation{
		config:        c,
		op:            op,
		typ:           TypeState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStateID sets the ID field of the mutation.
func withStateID(id int) stateOption {
	return func(m *StateMutation) {
		var (
			err   error
			once  sync.Once
			value *State
		)
		m.oldValue = func(ctx context.Context) (*State, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().State.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withState sets the old State of the mutation.
func withState(node *State) stateOption {
	return func(m *StateMutation) {
		m.oldValue = func(context.Context) (*State, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().State.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStateID sets the "state_id" field.
func (m *StateMutation) SetStateID(s string) {
	m.state_id = &s
}

// StateID returns the value of the "state_id" field in the mutation.
func (m *StateMutation) StateID() (r string, exists bool) {
	v := m.state_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStateID returns the old "state_id" field's value of the State entity.
// If the State object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StateMutation) OldStateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateID: %w", err)
	}
	return oldValue.StateID, nil
}

// ResetStateID resets all changes to the "state_id" field.
func (m *StateMutation) ResetStateID() {
	m.state_id = nil
}

// SetValue sets the "value" field.
func (m *StateMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *StateMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the State entity.
// If the State object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StateMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *StateMutation) ResetValue() {
	m.value = nil
}

// SetTag sets the "tag" field.
func (m *StateMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *StateMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the State entity.
// If the State object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StateMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ResetTag resets all changes to the "tag" field.
func (m *StateMutation) ResetTag() {
	m.tag = nil
}

// SetDatatype sets the "datatype" field.
func (m *StateMutation) SetDatatype(s string) {
	m.datatype = &s
}

// Datatype returns the value of the "datatype" field in the mutation.
func (m *StateMutation) Datatype() (r string, exists bool) {
	v := m.datatype
	if v == nil {
		return
	}
	return *v, true
}

// OldDatatype returns the old "datatype" field's value of the State entity.
// If the State object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StateMutation) OldDatatype(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatatype is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatatype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatatype: %w", err)
	}
	return oldValue.Datatype, nil
}

// ResetDatatype resets all changes to the "datatype" field.
func (m *StateMutation) ResetDatatype() {
	m.datatype = nil
}

// SetOperation sets the "operation" field.
func (m *StateMutation) SetOperation(s string) {
	m.operation = &s
}

// Operation returns the value of the "operation" field in the mutation.
func (m *StateMutation) Operation() (r string, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the State entity.
// If the State object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StateMutation) OldOperation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *StateMutation) ResetOperation() {
	m.operation = nil
}

// Where appends a list predicates to the StateMutation builder.
func (m *StateMutation) Where(ps ...predicate.State) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.State, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (State).
func (m *StateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StateMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.state_id != nil {
		fields = append(fields, state.FieldStateID)
	}
	if m.value != nil {
		fields = append(fields, state.FieldValue)
	}
	if m.tag != nil {
		fields = append(fields, state.FieldTag)
	}
	if m.datatype != nil {
		fields = append(fields, state.FieldDatatype)
	}
	if m.operation != nil {
		fields = append(fields, state.FieldOperation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case state.FieldStateID:
		return m.StateID()
	case state.FieldValue:
		return m.Value()
	case state.FieldTag:
		return m.Tag()
	case state.FieldDatatype:
		return m.Datatype()
	case state.FieldOperation:
		return m.Operation()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case state.FieldStateID:
		return m.OldStateID(ctx)
	case state.FieldValue:
		return m.OldValue(ctx)
	case state.FieldTag:
		return m.OldTag(ctx)
	case state.FieldDatatype:
		return m.OldDatatype(ctx)
	case state.FieldOperation:
		return m.OldOperation(ctx)
	}
	return nil, fmt.Errorf("unknown State field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case state.FieldStateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateID(v)
		return nil
	case state.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case state.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case state.FieldDatatype:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatatype(v)
		return nil
	case state.FieldOperation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	}
	return fmt.Errorf("unknown State field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown State numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown State nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StateMutation) ResetField(name string) error {
	switch name {
	case state.FieldStateID:
		m.ResetStateID()
		return nil
	case state.FieldValue:
		m.ResetValue()
		return nil
	case state.FieldTag:
		m.ResetTag()
		return nil
	case state.FieldDatatype:
		m.ResetDatatype()
		return nil
	case state.FieldOperation:
		m.ResetOperation()
		return nil
	}
	return fmt.Errorf("unknown State field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown State unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown State edge %s", name)
}

// TestMutation represents an operation that mutates the Test nodes in the graph.
type TestMutation struct {
	config
	op            Op
	typ           string
	id            *int
	test_id       *string
	comment       *string
	object_id     *string
	state_id      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Test, error)
	predicates    []predicate.Test
}

var _ ent.Mutation = (*TestMutation)(nil)

// testOption allows management of the mutation configuration using functional options.
type testOption func(*TestMutation)

// newTestMutation creates new mutation for the Test entity.
func newTestMutation(c config, op Op, opts ...testOption) *TestMutation {
	m := &TestMutation{
		config:        c,
		op:            op,
		typ:           TypeTest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestID sets the ID field of the mutation.
func withTestID(id int) testOption {
	return func(m *TestMutation) {
		var (
			err   error
			once  sync.Once
			value *Test
		)
		m.oldValue = func(ctx context.Context) (*Test, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Test.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTest sets the old Test of the mutation.
func withTest(node *Test) testOption {
	return func(m *TestMutation) {
		m.oldValue = func(context.Context) (*Test, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Test.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTestID sets the "test_id" field.
func (m *TestMutation) SetTestID(s string) {
	m.test_id = &s
}

// TestID returns the value of the "test_id" field in the mutation.
func (m *TestMutation) TestID() (r string, exists bool) {
	v := m.test_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTestID returns the old "test_id" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldTestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestID: %w", err)
	}
	return oldValue.TestID, nil
}

// ResetTestID resets all changes to the "test_id" field.
func (m *TestMutation) ResetTestID() {
	m.test_id = nil
}

// SetComment sets the "comment" field.
func (m *TestMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *TestMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *TestMutation) ResetComment() {
	m.comment = nil
}

// SetObjectID sets the "object_id" field.
func (m *TestMutation) SetObjectID(s string) {
	m.object_id = &s
}

// ObjectID returns the value of the "object_id" field in the mutation.
func (m *TestMutation) ObjectID() (r string, exists bool) {
	v := m.object_id
	if v == nil {
		return
	}
	return *v, true
}

// OldObjectID returns the old "object_id" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldObjectID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjectID: %w", err)
	}
	return oldValue.ObjectID, nil
}

// ResetObjectID resets all changes to the "object_id" field.
func (m *TestMutation) ResetObjectID() {
	m.object_id = nil
}

// SetStateID sets the "state_id" field.
func (m *TestMutation) SetStateID(s string) {
	m.state_id = &s
}

// StateID returns the value of the "state_id" field in the mutation.
func (m *TestMutation) StateID() (r string, exists bool) {
	v := m.state_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStateID returns the old "state_id" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldStateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateID: %w", err)
	}
	return oldValue.StateID, nil
}

// ResetStateID resets all changes to the "state_id" field.
func (m *TestMutation) ResetStateID() {
	m.state_id = nil
}

// Where appends a list predicates to the TestMutation builder.
func (m *TestMutation) Where(ps ...predicate.Test) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Test, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Test).
func (m *TestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.test_id != nil {
		fields = append(fields, test.FieldTestID)
	}
	if m.comment != nil {
		fields = append(fields, test.FieldComment)
	}
	if m.object_id != nil {
		fields = append(fields, test.FieldObjectID)
	}
	if m.state_id != nil {
		fields = append(fields, test.FieldStateID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case test.FieldTestID:
		return m.TestID()
	case test.FieldComment:
		return m.Comment()
	case test.FieldObjectID:
		return m.ObjectID()
	case test.FieldStateID:
		return m.StateID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case test.FieldTestID:
		return m.OldTestID(ctx)
	case test.FieldComment:
		return m.OldComment(ctx)
	case test.FieldObjectID:
		return m.OldObjectID(ctx)
	case test.FieldStateID:
		return m.OldStateID(ctx)
	}
	return nil, fmt.Errorf("unknown Test field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case test.FieldTestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestID(v)
		return nil
	case test.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case test.FieldObjectID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjectID(v)
		return nil
	case test.FieldStateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateID(v)
		return nil
	}
	return fmt.Errorf("unknown Test field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Test numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Test nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestMutation) ResetField(name string) error {
	switch name {
	case test.FieldTestID:
		m.ResetTestID()
		return nil
	case test.FieldComment:
		m.ResetComment()
		return nil
	case test.FieldObjectID:
		m.ResetObjectID()
		return nil
	case test.FieldStateID:
		m.ResetStateID()
		return nil
	}
	return fmt.Errorf("unknown Test field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Test unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Test edge %s", name)
}
